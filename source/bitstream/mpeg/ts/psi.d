
module bitstream.mpeg.ts.psi;

import std.array;
import std.bitmanip;
import std.exception;
import std.container;
import std.stdint;
import bitstream.mpeg.ts.TsPacket;


uint16_t pat_program_get_program_number(const ubyte[] p)
{
	return (p[0] << 8) | p[1];
}

uint16_t pat_program_get_pid(const ubyte[] p)
{
	return ( (p[2] & 0x1f ) << 8) | p[3];
}

class Program
{
	uint16_t pmt_pid;
	uint16_t program_number;
}

struct PatSection
{

	static uint16_t section_length(const ubyte[] s)
	{
		return (( (s[1] & 0x0f ) << 8 ) | s[2]);
	}

	static Program[] parse_programs(const ubyte[] s)
	{
		Program[] programs;

		assert( s[0] == 0 );

		auto programs_section_end = 8 + section_length(s) - 9;

		for (size_t i = 8;
			 i < programs_section_end;
			 i += 4 )
		{
			auto off = s[i..i+4];
			auto p = new Program;
			p.pmt_pid = pat_program_get_pid(off);
			p.program_number = pat_program_get_program_number(off);
			programs ~= p ;
		}
		return programs;
	}

};

struct PmtSection
{

	immutable static PMT_HEADER_SIZE = 12;

	static uint16_t section_length(const ubyte[] s)
	{
		return ( (s[1] & 0x0f ) << 8 ) | s[2];
	}

	static uint16_t program_info_length(const ubyte[] s)
	{
		return ((s[10] & 0x0f ) << 8) | s[11];
	}


	static PmtStream[] parse_streams(const ubyte[] s)
	{
		PmtStream[] streams;

		auto stream_data_start = 12 + program_info_length(s);

		//debug log("PmtStream section_length: %s", section_length(s));
		//debug log("PmtStream : program_info_length %s", program_info_length(s));

		auto stream_data_end = 12 + section_length(s) + 3 - PMT_HEADER_SIZE - 4;

		PmtStream *  stream = null;

		for (auto off = stream_data_start;
			 off < stream_data_end;
			 off += stream.length() )
		{
			stream = cast(PmtStream*) &s[off];

			enforce( stream.is_valid(), "PmtSection: stream is not valid" );

			streams ~= *stream;
		}
		return streams;
	}

	unittest
	{

	}

};

class Pat
{
	public Program[] programs;

	this(Program[] p)
	{
		programs = p;
	}

	bool is_pmt_pid(uint16_t pid)
	{
		foreach(p;programs)
		{
			if( p.pmt_pid == pid )
			{
				return true;
			}
		}

		return false;
	}
}

class PatBuilder
{
	const(TsPacket)[] _packets;
public:
	void add_packet(const TsPacket pkt)
	{
		_packets ~= pkt;
	}

	Pat build()
	{
		while( _packets.length > 0 && ! _packets[0].unitstart )
		{
			_packets = _packets[1..$];
		}

		if( _packets.length == 0 )
		{
			return null;
		}

		auto pkt = _packets[0];

		auto section = pkt.section();

		return new Pat(PatSection.parse_programs(section));
	}
}

struct PmtStream
{
public:

	uint8_t stream_type() const @property
	{
		return _stream_type;
	}

	uint16_t elementary_pid() const @property
	{
		return (elementary_pid1 << 8) | elementary_pid2;
	}

	uint16_t es_info_length() const
	{
		return (es_info_length1 << 8) | es_info_length2;
	}

	uint16_t length() const
	{
		return cast(uint16_t)(es_info_length() + cast(uint16_t)PmtStream.sizeof);
	}
	bool is_valid() const
	{
		return ( (es_info_length1 & 0x0c ) == 0 ) ;
	}
private:
	uint8_t _stream_type;

	mixin( bitfields!(
		ubyte, "elementary_pid1", 5,
		ubyte, "reserved1", 3
	));

	//uint8_t elementary_pid1 :5;
	//uint8_t reserved1 :3;

	uint8_t elementary_pid2;

	mixin( bitfields!(
		ubyte, "es_info_length1", 4,
		ubyte, "reserved2", 4
	));
	//uint8_t es_info_length1 :4;
	//uint8_t reserved2 :4;

	uint8_t es_info_length2;
}

class Pmt
{
	this(const PmtStream[] streams, uint16_t pcr_pid )
	{
		_streams = streams;
		_pcr_pid = pcr_pid;
	}

	const PmtStream[] _streams;
	uint16_t _pcr_pid;
public:
	@property const(PmtStream[]) streams() const
	{
		return cast(const(PmtStream[]))_streams;
	}

	//uint16_t get_pcr_pid() const;
}

class PmtBuilder
{
	const(TsPacket)[] _packets;
public:
	void add_packet(const TsPacket pkt)
	{
		_packets ~= pkt;
	}

	Pmt build()
	{
		while( _packets.length > 0 && ! _packets[0].unitstart )
		{
			_packets = _packets[1..$];
		}

		if( _packets.length == 0 )
		{
			return null;
		}

		auto pkt = _packets[0];

		auto section = pkt.section();

		return new Pmt(PmtSection.parse_streams(section), 0 );
	}
}

unittest
{
	auto pkt = new TsPacket([0x47, 0x40, 0x0, 0x17, 0x0, 0x0, 0xb0, 0xd, 0x0, 0x1, 0xc1, 0x0, 0x0, 0x0, 0x1, 0xf0, 0x0, 0x2a, 0xb1, 0x4, 0xb2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,0xff]);

	auto patb = new PatBuilder;
	patb.add_packet(pkt);

	auto pat = patb.build();

	assert(patb !is null);
	assert(pat.programs.length == 1);
	assert(pat.programs[0].pmt_pid == 4096);
	assert(pat.programs[0].program_number == 1);
	assert(pat.is_pmt_pid(4096));
	assert(! pat.is_pmt_pid(4097));
	assert(! pat.is_pmt_pid(4095));
	assert(! pat.is_pmt_pid(0));
}

unittest
{
	auto pkt = new TsPacket([0x47, 0x50, 0x0, 0x17, 0x0, 0x2, 0xb0, 0x17, 0x0, 0x1, 0xc1, 0x0, 0x0, 0xe1, 0x0, 0xf0, 0x0, 0x1b, 0xe1, 0x0, 0xf0, 0x0, 0xf, 0xe1, 0x1, 0xf0, 0x0, 0x2f, 0x44, 0xb9, 0x9b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,0xff]);

	auto pmtb = new PmtBuilder;
	pmtb.add_packet(pkt);

	auto pmt = pmtb.build();

	assert(pmtb !is null);
	assert(pmt.streams.length == 2);
	assert(pmt.streams[0].elementary_pid == 256);
	assert(pmt.streams[0].stream_type == 0x1b);
	assert(pmt.streams[1].elementary_pid == 257);
	assert(pmt.streams[1].stream_type == 0x0f);
}

